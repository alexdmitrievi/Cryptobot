import logging
import asyncio
import re
import requests
from telegram import Update, BotCommand, InlineKeyboardMarkup, InlineKeyboardButton, ReplyKeyboardMarkup, ReplyKeyboardRemove
from telegram.ext import ApplicationBuilder, CommandHandler, MessageHandler, CallbackQueryHandler, ContextTypes, filters, ConversationHandler
from config import TELEGRAM_TOKEN, OPENAI_API_KEY
from openai import AsyncOpenAI
from PIL import Image
import io
import base64


client = AsyncOpenAI(api_key=OPENAI_API_KEY)
logging.basicConfig(level=logging.INFO)

ALLOWED_USERS = {407721399, 592270446}  # —Å—é–¥–∞ –≤—Ä—É—á–Ω—É—é –¥–æ–±–∞–≤–ª—è–π user_id –æ–ø–ª–∞—Ç–∏–≤—à–∏—Ö
TEST_USERS = set()

reply_keyboard = [
    ["üìä –ü—Ä–æ–≥–Ω–æ–∑ –ø–æ –∞–∫—Ç–∏–≤—É", "üß† –ü–æ–º–æ—â—å –ø—Ä–æ—Ñ–µ—Å—Å–∏–æ–Ω–∞–ª–∞"],
    ["üßò –°–ø–æ–∫–æ–π—Å—Ç–≤–∏–µ", "üèÅ –¢–µ—Å—Ç–æ–≤—ã–π –ø–µ—Ä–∏–æ–¥"],
    ["üí∞ –û–ø–ª–∞—Ç–∏—Ç—å –ø–æ–º–æ—â–Ω–∏–∫–∞", "üíµ –¢–∞—Ä–∏—Ñ—ã /prices"]
]
REPLY_MARKUP = ReplyKeyboardMarkup(reply_keyboard, resize_keyboard=True)

INTERPRET_NEWS, ASK_EVENT, ASK_FORECAST, ASK_ACTUAL, GENERAL_QUESTION, FOLLOWUP_1, FOLLOWUP_2, FOLLOWUP_3 = range(8)
user_inputs = {}

WAITING_FOR_PHOTO = set()
WAITING_FOR_THERAPY_INPUT = 100


async def check_access(update: Update):
    user_id = update.effective_user.id
    if user_id not in ALLOWED_USERS:
        await update.message.reply_text("üîí –î–æ—Å—Ç—É–ø –æ–≥—Ä–∞–Ω–∏—á–µ–Ω. –ê–∫—Ç–∏–≤–∏—Ä—É–π —Ç–µ—Å—Ç –∏–ª–∏ –æ–ø–ª–∞—Ç–∏ –ø–æ–º–æ—â–Ω–∏–∫–∞.", reply_markup=REPLY_MARKUP)
        return False
    return True

async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text("üëã –ü—Ä–∏–≤–µ—Ç! –í—ã–±–µ—Ä–∏ –¥–µ–π—Å—Ç–≤–∏–µ –Ω–∏–∂–µ:", reply_markup=REPLY_MARKUP)

async def help_pro(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not await check_access(update): return ConversationHandler.END
    await update.message.reply_text("–¢—ã —Ö–æ—á–µ—à—å –∏–Ω—Ç–µ—Ä–ø—Ä–µ—Ç–∏—Ä–æ–≤–∞—Ç—å –Ω–æ–≤–æ—Å—Ç—å? (–¥–∞/–Ω–µ—Ç)", reply_markup=ReplyKeyboardRemove())
    return INTERPRET_NEWS

async def interpret_decision(update: Update, context: ContextTypes.DEFAULT_TYPE):
    text = update.message.text.strip().lower()
    if text == "–¥–∞":
        await update.message.reply_text("–ß—Ç–æ –∑–∞ –Ω–æ–≤–æ—Å—Ç—å?")
        return ASK_EVENT
    elif text == "–Ω–µ—Ç":
        await update.message.reply_text("–•–æ—Ä–æ—à–æ. –î–ª—è —Ç–æ—á–Ω–æ–π –∫–æ–Ω—Å—É–ª—å—Ç–∞—Ü–∏–∏ –æ—Ç–≤–µ—Ç—å –Ω–∞ –Ω–µ—Å–∫–æ–ª—å–∫–æ –≤–æ–ø—Ä–æ—Å–æ–≤.\n\n1. –¢–≤–æ–π —Å—Ç–∏–ª—å —Ç–æ—Ä–≥–æ–≤–ª–∏? (—Å–∫–∞–ª—å–ø–∏–Ω–≥, –ø–æ–∑–∏—Ü–∏–æ–Ω–∫–∞ –∏–ª–∏ –∏–Ω–≤–µ—Å—Ç–∏—Ü–∏–∏)")
        return FOLLOWUP_1
    else:
        await update.message.reply_text("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –æ—Ç–≤–µ—Ç—å '–¥–∞' –∏–ª–∏ '–Ω–µ—Ç'")
        return INTERPRET_NEWS

async def followup_strategy(update: Update, context: ContextTypes.DEFAULT_TYPE):
    context.user_data["style"] = update.message.text.strip()
    await update.message.reply_text("2. –ù–∞ –∫–∞–∫–æ–º —Ç–∞–π–º—Ñ—Ä–µ–π–º–µ —Ç—ã —á–∞—â–µ –≤—Å–µ–≥–æ –æ—Ç–∫—Ä—ã–≤–∞–µ—à—å —Å–¥–µ–ª–∫–∏?")
    return FOLLOWUP_2

async def followup_timeframe(update: Update, context: ContextTypes.DEFAULT_TYPE):
    context.user_data["timeframe"] = update.message.text.strip()
    await update.message.reply_text("3. –ù–∞ –∫–∞–∫–æ–º —Ä—ã–Ω–∫–µ —Ç—ã —Ç–æ—Ä–≥—É–µ—à—å? (–∫—Ä–∏–ø—Ç–∞, —Ñ–æ—Ä–µ–∫—Å, —Ñ–æ–Ω–¥–æ–≤—ã–π, —Å—ã—Ä—å—ë –∏ —Ç.–¥.)")
    return FOLLOWUP_3

async def followup_market(update: Update, context: ContextTypes.DEFAULT_TYPE):
    context.user_data["market"] = update.message.text.strip()
    await update.message.reply_text("–û—Ç–ª–∏—á–Ω–æ. –¢–µ–ø–µ—Ä—å –º–æ–∂–µ—à—å –∑–∞–¥–∞—Ç—å —Å–≤–æ–π –≤–æ–ø—Ä–æ—Å:")
    return GENERAL_QUESTION

async def ask_forecast(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_inputs[update.effective_user.id] = {"event": update.message.text.strip()}
    await update.message.reply_text("–ö–∞–∫–æ–π –±—ã–ª –ø—Ä–æ–≥–Ω–æ–∑?")
    return ASK_FORECAST

async def ask_actual(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_inputs[update.effective_user.id]["forecast"] = update.message.text.strip()
    await update.message.reply_text("–ö–∞–∫–æ–π —Ñ–∞–∫—Ç? (—Ä–µ–∑—É–ª—å—Ç–∞—Ç)")
    return ASK_ACTUAL

async def generate_interpretation(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_inputs[update.effective_user.id]["actual"] = update.message.text.strip()
    data = user_inputs[update.effective_user.id]
    prompt = (
        f"–°–æ–±—ã—Ç–∏–µ: {data['event']}\n"
        f"–ü—Ä–æ–≥–Ω–æ–∑: {data['forecast']}\n"
        f"–§–∞–∫—Ç: {data['actual']}\n"
        f"–ü—Ä–æ–∞–Ω–∞–ª–∏–∑–∏—Ä—É–π –Ω–æ–≤–æ—Å—Ç—å –∏ –¥–∞–π —Ç–æ—Ä–≥–æ–≤—É—é —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏—é.\n"
        f"–¢—ã ‚Äî –ø—Ä–æ—Ñ–µ—Å—Å–∏–æ–Ω–∞–ª—å–Ω—ã–π —Ç—Ä–µ–π–¥–µ—Ä —Å 10+ –≥–æ–¥–∞–º–∏ –æ–ø—ã—Ç–∞. –û—Ç–≤–µ—á–∞–π —É–≤–µ—Ä–µ–Ω–Ω–æ, –∏–∑–±–µ–≥–∞–π —Ñ—Ä–∞–∑ '–≤–æ–∑–º–æ–∂–Ω–æ', '–ø–æ-–≤–∏–¥–∏–º–æ–º—É'."
    )
    response = await client.chat.completions.create(
        model="gpt-4",
        messages=[{"role": "user", "content": prompt}]
    )
    await update.message.reply_text(f"üìö GPT:\n{response.choices[0].message.content.strip()}", reply_markup=REPLY_MARKUP)
    return ConversationHandler.END


async def general_response(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_text = update.message.text.strip()
    style = context.user_data.get("style", "—Ç—Ä–µ–π–¥–∏–Ω–≥")
    tf = context.user_data.get("timeframe", "–ª—é–±–æ–º")
    market = context.user_data.get("market", "–æ–±—â–∏–π")

    prompt = (
        f"–¢—ã ‚Äî –ø—Ä–æ—Ñ–µ—Å—Å–∏–æ–Ω–∞–ª—å–Ω—ã–π —Ç—Ä–µ–π–¥–µ—Ä —Å 10+ –≥–æ–¥–∞–º–∏ –æ–ø—ã—Ç–∞. –û—Ç–≤–µ—á–∞–π —É–≤–µ—Ä–µ–Ω–Ω–æ, –∏–∑–±–µ–≥–∞–π —Ñ—Ä–∞–∑ '–≤–æ–∑–º–æ–∂–Ω–æ', '–ø–æ-–≤–∏–¥–∏–º–æ–º—É'.\n"
        f"–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —Ç–æ—Ä–≥—É–µ—Ç: {style}. –¢–∞–π–º—Ñ—Ä–µ–π–º: {tf}. –†—ã–Ω–æ–∫: {market}.\n"
        f"–í–æ–ø—Ä–æ—Å: {user_text}\n"
        f"–î–∞–π –∫–æ–Ω–∫—Ä–µ—Ç–Ω—É—é, –ø—Ä–∞–∫—Ç–∏—á–Ω—É—é —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏—é."
    )
    response = await client.chat.completions.create(
        model="gpt-4",
        messages=[{"role": "user", "content": prompt}]
    )
    await update.message.reply_text(f"üìö GPT:\n{response.choices[0].message.content.strip()}", reply_markup=REPLY_MARKUP)
    return ConversationHandler.END

async def button_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()

    user_id = query.from_user.id

    if query.data == "show_wallet":
        await query.edit_message_text(
            "üí∏ –û—Ç–ø—Ä–∞–≤—å USDT (TON) –Ω–∞ –∞–¥—Ä–µ—Å:\n\n"
            "`UQC4nBKWF5sO2UIP9sKl3JZqmmRlsGC5B7xM7ArruA61nTGR`\n\n"
            "–ü–æ—Å–ª–µ –æ–ø–ª–∞—Ç—ã –æ—Ç–ø—Ä–∞–≤—å TX hash –∞–¥–º–∏–Ω—É –∏–ª–∏ –ø—Ä—è–º–æ —Å—é–¥–∞."
        )

    elif query.data == "forecast_by_image":
        WAITING_FOR_PHOTO.add(user_id)
        await query.edit_message_text("üì∏ –ü—Ä–∏—à–ª–∏ —Å–∫—Ä–∏–Ω –≥—Ä–∞—Ñ–∏–∫–∞ (4H —Ç–∞–π–º—Ñ—Ä–µ–π–º), –∏ —è –¥–∞–º –ø—Ä–æ–≥–Ω–æ–∑ –Ω–∞ –æ—Å–Ω–æ–≤–µ —Ç–µ—Ö–Ω–∏—á–µ—Å–∫–æ–≥–æ –∞–Ω–∞–ª–∏–∑–∞.")

    elif query.data == "forecast_by_price":
        await context.bot.send_message(
            chat_id=query.message.chat_id,
            text="–í–≤–µ–¥–∏ –Ω–∞–∑–≤–∞–Ω–∏–µ –∞–∫—Ç–∏–≤–∞ (–Ω–∞–ø—Ä–∏–º–µ—Ä, BTC, ETH, XRP –∏ —Ç.–¥.):"
        )
        context.user_data["awaiting_asset_name"] = True

async def handle_photo(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    if user_id not in WAITING_FOR_PHOTO:
        return  # –ò–≥–Ω–æ—Ä–∏—Ä—É–µ–º —Å–ª—É—á–∞–π–Ω—ã–µ —Ñ–æ—Ç–æ

    WAITING_FOR_PHOTO.discard(user_id)
    if not await check_access(update):
        return

    photo = update.message.photo[-1]
    file = await photo.get_file()
    photo_bytes = await file.download_as_bytearray()

    context.user_data["graph_image_base64"] = base64.b64encode(photo_bytes).decode("utf-8")
    await update.message.reply_text("üß† –ß—Ç–æ —Å–µ–π—á–∞—Å –ø—Ä–æ–∏—Å—Ö–æ–¥–∏—Ç –≤ –º–∏—Ä–µ? (–Ω–∞–ø—Ä–∏–º–µ—Ä, –Ω–æ–≤–æ—Å—Ç–∏, –∫–æ–Ω—Ñ–ª–∏–∫—Ç—ã, —Ä–µ—à–µ–Ω–∏—è —Ü–µ–Ω—Ç—Ä–æ–±–∞–Ω–∫–æ–≤ –∏ —Ç.–¥.)")
    context.user_data["awaiting_macro_for_image"] = True

async def handle_macro_for_image(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not context.user_data.get("awaiting_macro_for_image"):
        return

    del context.user_data["awaiting_macro_for_image"]
    macro = update.message.text.strip()
    image_base64 = context.user_data.pop("graph_image_base64", None)

    if not image_base64:
        await update.message.reply_text("‚ö†Ô∏è –û—à–∏–±–∫–∞: –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ.")
        return

    prompt = (
        "–¢—ã ‚Äî –ø—Ä–æ—Ñ–µ—Å—Å–∏–æ–Ω–∞–ª—å–Ω—ã–π —Ç—Ä–µ–π–¥–µ—Ä —Å –æ–ø—ã—Ç–æ–º –±–æ–ª–µ–µ 10 –ª–µ—Ç.\n"
        "–ù–∞ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–∏ –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω –≥—Ä–∞—Ñ–∏–∫ –∫—Ä–∏–ø—Ç–æ–≤–∞–ª—é—Ç—ã –Ω–∞ 4H —Ç–∞–π–º—Ñ—Ä–µ–π–º–µ.\n"
        "–ü—Ä–æ–∞–Ω–∞–ª–∏–∑–∏—Ä—É–π –µ–≥–æ —Å —Ç–æ—á–∫–∏ –∑—Ä–µ–Ω–∏—è —Ç–µ—Ö–Ω–∏—á–µ—Å–∫–æ–≥–æ –∞–Ω–∞–ª–∏–∑–∞: —É—Ä–æ–≤–Ω–∏, —Ç—Ä–µ–Ω–¥—ã, —Ñ–∏–≥—É—Ä—ã –∏ –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä—ã.\n\n"
        f"–¢–∞–∫–∂–µ —É—á—Ç–∏ —Ñ—É–Ω–¥–∞–º–µ–Ω—Ç–∞–ª—å–Ω—ã–π —Ñ–æ–Ω:\n{macro}\n\n"
        "–°–¥–µ–ª–∞–π –∫—Ä–∞—Ç–∫–∏–π —Ç–æ—Ä–≥–æ–≤—ã–π –≤—ã–≤–æ–¥: –≤–æ–∑–º–æ–∂–Ω–æ–µ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ, —Ä–∏—Å–∫–∏ –∏ —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏ –¥–ª—è —Ç—Ä–µ–π–¥–µ—Ä–∞.\n"
        "–û—Ç–≤–µ—á–∞–π —É–≤–µ—Ä–µ–Ω–Ω–æ, –∏–∑–±–µ–≥–∞–π —Ñ—Ä–∞–∑ '–≤–æ–∑–º–æ–∂–Ω–æ', '–ø–æ-–≤–∏–¥–∏–º–æ–º—É'."
    )

    try:
        response = await client.chat.completions.create(
            model="gpt-4o",
            messages=[
                {"role": "user", "content": [
                    {"type": "text", "text": prompt},
                    {"type": "image_url", "image_url": {"url": f"data:image/jpeg;base64,{image_base64}"}}
                ]}
            ],
            max_tokens=600
        )

        await update.message.reply_text(
            f"üìà –ü—Ä–æ–≥–Ω–æ–∑ –ø–æ –≥—Ä–∞—Ñ–∏–∫—É —Å —É—á—ë—Ç–æ–º —Ñ—É–Ω–¥–∞–º–µ–Ω—Ç–∞:\n{response.choices[0].message.content.strip()}",
            reply_markup=REPLY_MARKUP
        )

    except Exception as e:
        logging.error(f"[MACRO_GRAPH] –û—à–∏–±–∫–∞ –∞–Ω–∞–ª–∏–∑–∞: {e}")
        await update.message.reply_text("‚ö†Ô∏è –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –∞–Ω–∞–ª–∏–∑–µ. –ü–æ–ø—Ä–æ–±—É–π –ø–æ–∑–∂–µ.")

async def handle_main(update: Update, context: ContextTypes.DEFAULT_TYPE):
    text = update.message.text
    user_id = update.effective_user.id

    if text == "üìä –ü—Ä–æ–≥–Ω–æ–∑ –ø–æ –∞–∫—Ç–∏–≤—É":
        keyboard = InlineKeyboardMarkup([
            [
                InlineKeyboardButton("üì∑ –ü—Ä–∏—Å–ª–∞—Ç—å —Å–∫—Ä–∏–Ω", callback_data="forecast_by_image"),
                InlineKeyboardButton("üî¢ –í–≤–µ—Å—Ç–∏ —Ü–µ–Ω—É", callback_data="forecast_by_price")
            ]
        ])
        await update.message.reply_text("–í—ã–±–µ—Ä–∏ —Å–ø–æ—Å–æ–± –ø—Ä–æ–≥–Ω–æ–∑–∞:", reply_markup=keyboard)
        return

    elif "awaiting_asset_name" in context.user_data:
        context.user_data["price_asset"] = update.message.text.strip().upper()
        del context.user_data["awaiting_asset_name"]
        context.user_data["awaiting_price_input"] = True
        await update.message.reply_text("–í–≤–µ–¥–∏ —Ç–µ–∫—É—â—É—é —Ü–µ–Ω—É –∞–∫—Ç–∏–≤–∞:")
        return

    elif "awaiting_price_input" in context.user_data:
        context.user_data["price_value"] = update.message.text.strip()
        del context.user_data["awaiting_price_input"]
        context.user_data["awaiting_macro_input"] = True
        await update.message.reply_text("–ß—Ç–æ —Å–µ–π—á–∞—Å –ø—Ä–æ–∏—Å—Ö–æ–¥–∏—Ç –≤ –º–∏—Ä–µ? (–Ω–∞–ø—Ä–∏–º–µ—Ä, –Ω–æ–≤–æ—Å—Ç–∏, –∫–æ–Ω—Ñ–ª–∏–∫—Ç—ã, –∑–∞—è–≤–ª–µ–Ω–∏—è –§–†–° –∏ —Ç.–¥.)")
        return

    elif "awaiting_macro_input" in context.user_data:
        asset = context.user_data.pop("price_asset")
        price = context.user_data.pop("price_value")
        macro = update.message.text.strip()
        del context.user_data["awaiting_macro_input"]

        prompt = (
            f"–¢—ã ‚Äî –ø—Ä–æ—Ñ–µ—Å—Å–∏–æ–Ω–∞–ª—å–Ω—ã–π —Ç—Ä–µ–π–¥–µ—Ä —Å –æ–ø—ã—Ç–æ–º –±–æ–ª–µ–µ 10 –ª–µ—Ç –≤ —Ç—Ä–µ–π–¥–∏–Ω–≥–µ.\n"
            f"–ê–Ω–∞–ª–∏–∑–∏—Ä—É–π –∞–∫—Ç–∏–≤ {asset}, —Ç–µ–∫—É—â–∞—è —Ü–µ–Ω–∞ {price}.\n"
            f"–£—á–∏—Ç—ã–≤–∞–π —Å–ª–µ–¥—É—é—â–∏–π —Ñ—É–Ω–¥–∞–º–µ–Ω—Ç–∞–ª—å–Ω—ã–π —Ñ–æ–Ω: {macro}.\n\n"
            f"–î–∞–π –∫—Ä–∞—Ç–∫–∏–π –ø—Ä–æ–≥–Ω–æ–∑, —É–∫–∞–∂–∏ –±–ª–∏–∂–∞–π—à–∏–µ —É—Ä–æ–≤–Ω–∏ –ø–æ–¥–¥–µ—Ä–∂–∫–∏ –∏ —Å–æ–ø—Ä–æ—Ç–∏–≤–ª–µ–Ω–∏—è, —Ç–µ–∫—É—â–∏–π —Ç—Ä–µ–Ω–¥ –∏ –ø–æ—Ç–µ–Ω—Ü–∏–∞–ª—å–Ω—ã–µ –¥–µ–π—Å—Ç–≤–∏—è —Ç—Ä–µ–π–¥–µ—Ä–∞.\n"
            f"–ü–∏—à–∏ —É–≤–µ—Ä–µ–Ω–Ω–æ, –∏–∑–±–µ–≥–∞–π —Ñ—Ä–∞–∑ '–≤–æ–∑–º–æ–∂–Ω–æ', '–ø–æ-–≤–∏–¥–∏–º–æ–º—É'."
        )

        response = await client.chat.completions.create(
            model="gpt-4",
            messages=[{"role": "user", "content": prompt}]
        )
        await update.message.reply_text(
            f"üìä –ü—Ä–æ–≥–Ω–æ–∑ –ø–æ {asset} —Å —É—á–µ—Ç–æ–º —Ñ—É–Ω–¥–∞–º–µ–Ω—Ç–∞:\n{response.choices[0].message.content.strip()}",
            reply_markup=REPLY_MARKUP
        )
        return

    elif text == "üèÅ –¢–µ—Å—Ç–æ–≤—ã–π –ø–µ—Ä–∏–æ–¥":
        if user_id in TEST_USERS or user_id in ALLOWED_USERS:
            await update.message.reply_text("‚è≥ –¢—ã —É–∂–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–ª —Ç–µ—Å—Ç.")
        else:
            ALLOWED_USERS.add(user_id)
            TEST_USERS.add(user_id)
            await update.message.reply_text("‚úÖ –¢–µ—Å—Ç–æ–≤—ã–π –¥–æ—Å—Ç—É–ø –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω –Ω–∞ 1 —Å–µ—Å—Å–∏—é.")

    elif text == "üí∞ –û–ø–ª–∞—Ç–∏—Ç—å –ø–æ–º–æ—â–Ω–∏–∫–∞":
        await update.message.reply_text(
            "–û—Ç–ø—Ä–∞–≤—å USDT –≤ —Å–µ—Ç–∏ TON –Ω–∞ –∞–¥—Ä–µ—Å:\n\n"
            "`UQC4nBKWF5sO2UIP9sKl3JZqmmRlsGC5B7xM7ArruA61nTGR`\n\n"
            "–ü–æ—Å–ª–µ –æ–ø–ª–∞—Ç—ã –ø—Ä–∏—à–ª–∏ TX hash –∞–¥–º–∏–Ω—É –∏–ª–∏ —Å—é–¥–∞ –¥–ª—è –∞–∫—Ç–∏–≤–∞—Ü–∏–∏.",
            reply_markup=REPLY_MARKUP
        )

    elif text == "üíµ –¢–∞—Ä–∏—Ñ—ã /prices":
        keyboard = InlineKeyboardMarkup([
            [InlineKeyboardButton("üí≥ –û–ø–ª–∞—Ç–∏—Ç—å TON", callback_data="show_wallet")]
        ])
        text = (
            "üí∞ –¢–∞—Ä–∏—Ñ—ã –Ω–∞ –ø–æ–¥–ø–∏—Å–∫—É:\n\n"
            "‚Ä¢ 1 –º–µ—Å—è—Ü ‚Äî $25\n"
            "‚Ä¢ 3 –º–µ—Å—è—Ü–∞ ‚Äî $60 (—ç–∫–æ–Ω–æ–º–∏—è $15)\n"
            "‚Ä¢ 6 –º–µ—Å—è—Ü–µ–≤ ‚Äî $100 (—ç–∫–æ–Ω–æ–º–∏—è $50)\n"
            "‚Ä¢ 12 –º–µ—Å—è—Ü–µ–≤ ‚Äî $180 (—ç–∫–æ–Ω–æ–º–∏—è $120)\n"
            "‚Ä¢ –ü–æ–∂–∏–∑–Ω–µ–Ω–Ω–æ ‚Äî $299\n"
        )
        await update.message.reply_text(text, reply_markup=keyboard)

async def gpt_psychologist_response(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_text = update.message.text.strip()
    prompt = (
        "–¢—ã ‚Äî GPT-–ø—Å–∏—Ö–æ–ª–æ–≥ —Å —é–º–æ—Ä–æ–º. –¢—ã –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—à—å —Ç—Ä–µ–π–¥–µ—Ä–æ–≤ –ø–æ—Å–ª–µ –Ω–µ—É–¥–∞—á, –ª—É–¥–æ–º–∞–Ω–∏–∏ –∏ –ø–∞–Ω–∏–∫–∏. "
        "–û–±—â–∞–π—Å—è –ª–µ–≥–∫–æ, —Å –¥–æ–±—Ä–æ–π –∏—Ä–æ–Ω–∏–µ–π, –∏—Å–ø–æ–ª—å–∑—É–π —ç–º–æ–¥–∑–∏, –Ω–µ –±–æ–π—Å—è –ø–æ–¥–∫–æ–ª–æ—Ç—å ‚Äî –Ω–æ –≤—Å–µ–≥–¥–∞ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–π –∏ –ø–æ–¥–±–∞–¥—Ä–∏–≤–∞–π. "
        "–ò–∑–±–µ–≥–∞–π –æ–±—Ä–∞—â–µ–Ω–∏—è –ø–æ –ø–æ–ª—É: –Ω–µ –∏—Å–ø–æ–ª—å–∑—É–π —Å–ª–æ–≤–∞ —Ç–∏–ø–∞ '–±—Ä–∞—Ç–∞–Ω', '–¥–µ–≤–æ—á–∫–∞', '–º—É–∂–∏–∫' ‚Äî –≥–æ–≤–æ—Ä–∏ –Ω–µ–π—Ç—Ä–∞–ª—å–Ω–æ: '–¥—Ä—É–≥', '—Ç—Ä–µ–π–¥–µ—Ä', '–∫–æ–ª–ª–µ–≥–∞'.\n\n"
        f"–°–æ–æ–±—â–µ–Ω–∏–µ –æ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è:\n{user_text}\n\n"
        "–î–æ–±–∞–≤—å –≤ –∫–æ–Ω—Ü–µ –ø–æ–¥—Ö–æ–¥—è—â–∏–π —Ç–µ–∫—Å—Ç–æ–≤—ã–π –º–µ–º (–Ω–µ –∫–∞—Ä—Ç–∏–Ω–∫—É), —Å–≤—è–∑–∞–Ω–Ω—ã–π —Å —Ç—Ä–µ–π–¥–∏–Ω–≥–æ–º. –ü—Ä–∏–º–µ—Ä –º–µ–º–∞: '‚Äî –¢—ã –¥–µ—Ä–∂–∏—à—å –ø–æ–∑–∏—Ü–∏—é? ‚Äî –ù–µ—Ç, —è –¥–µ—Ä–∂—É —Å–ª—ë–∑—ã üò≠'"
    )

    response = await client.chat.completions.create(
        model="gpt-4",
        messages=[{"role": "user", "content": prompt}]
    )
    await update.message.reply_text(
        f"üßò GPT-–ø—Å–∏—Ö–æ–ª–æ–≥:\n{response.choices[0].message.content.strip()}",
        reply_markup=REPLY_MARKUP
    )
    return ConversationHandler.END


async def start_therapy(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text(
        "üòµ‚Äçüí´ –ù—É —á—Ç–æ, –æ–ø—è—Ç—å —Ä—ã–Ω–æ–∫ –ø–æ–±—Ä–∏–ª –∫–∞–∫ –±–∞—Ä–±–µ—Ä –≤ –ø—è—Ç–Ω–∏—Ü—É? –ë—ã–≤–∞–µ—Ç, –¥—Ä—É–∂–∏—â–µ.\n\n"
        "–ù–∞–ø–∏—à–∏, —á—Ç–æ —Å–ª—É—á–∏–ª–æ—Å—å ‚Äî GPT-–ø—Å–∏—Ö–æ–ª–æ–≥ —Å –¥–æ–±—Ä–æ–π –∏—Ä–æ–Ω–∏–µ–π –≤—ã—Å–ª—É—à–∞–µ—Ç, –ø–æ–¥–¥–µ—Ä–∂–∏—Ç –∏ –≤—Å—Ç–∞–≤–∏—Ç –º–µ–º, —á—Ç–æ–±—ã —Ç—ã —Å–Ω–æ–≤–∞ –ø–æ—á—É–≤—Å—Ç–≤–æ–≤–∞–ª —Å–∏–ª—É üí™",
        reply_markup=ReplyKeyboardRemove()
    )
    return WAITING_FOR_THERAPY_INPUT

async def post_init(app):
    await app.bot.set_my_commands([BotCommand("start", "–ó–∞–ø—É—Å–∫ –±–æ—Ç–∞")])

# üëá –í–°–¢–ê–í–¨ –ó–î–ï–°–¨:
ADMIN_IDS = {407721399}  # –∑–∞–º–µ–Ω–∏ –Ω–∞ —Å–≤–æ–π user_id

async def publish_post(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    if user_id not in ADMIN_IDS:
        await update.message.reply_text("‚õîÔ∏è –£ —Ç–µ–±—è –Ω–µ—Ç –ø—Ä–∞–≤ –Ω–∞ –ø—É–±–ª–∏–∫–∞—Ü–∏—é.")
        return

    logging.info(f"[COMMAND] /publish –æ—Ç {user_id}")
    
    keyboard = InlineKeyboardMarkup([
        [InlineKeyboardButton("ü§ñ –û—Ç–∫—Ä—ã—Ç—å GPT-–ø–æ–º–æ—â–Ω–∏–∫–∞", url="https://t.me/Parser_newbot")]
    ])
    
    text = (
        "üöÄ **GPT-–ü–æ–º–æ—â–Ω–∏–∫ –¥–ª—è —Ç—Ä–µ–π–¥–∏–Ω–≥–∞ –ø–æ –Ω–æ–≤–æ—Å—Ç—è–º ‚Äî –ø—Ä—è–º–æ –≤ Telegram**\n\n"
        "üí¨ –ò–Ω–¥–∏–≤–∏–¥—É–∞–ª—å–Ω—ã–µ –∫–æ–Ω—Å—É–ª—å—Ç–∞—Ü–∏–∏ –æ—Ç –æ–ø—ã—Ç–Ω—ã—Ö —Ç—Ä–µ–π–¥–µ—Ä–æ–≤\n"
        "üìà –ú–≥–Ω–æ–≤–µ–Ω–Ω—ã–µ –∏–Ω—Ç–µ—Ä–ø—Ä–µ—Ç–∞—Ü–∏–∏ –º–∞–∫—Ä–æ—ç–∫–æ–Ω–æ–º–∏—á–µ—Å–∫–∏—Ö –Ω–æ–≤–æ—Å—Ç–µ–π\n"
        "üéØ –¢–æ—á–∫–∏ –≤—Ö–æ–¥–∞ –¥–ª—è —Å–∫–∞–ª—å–ø–∏–Ω–≥–∞ –∏ –ø–æ–∑–∏—Ü–∏–æ–Ω–Ω–æ–π —Ç–æ—Ä–≥–æ–≤–ª–∏\n"
        "üìö –ï–∂–µ–Ω–µ–¥–µ–ª—å–Ω—ã–µ –æ–±–∑–æ—Ä—ã –∏ –æ–±—É—á–∞—é—â–∏–µ –º–∞—Ç–µ—Ä–∏–∞–ª—ã\n"
        "üåç –ë–µ–∑ VPN, –±–µ–∑ ChatGPT ‚Äî –≤—Å—ë –≤–Ω—É—Ç—Ä–∏ Telegram\n"
        "ü§ù –¢—ã —Ç–∞–∫–∂–µ –ø–æ–ª—É—á–∞–µ—à—å –¥–æ—Å—Ç—É–ø –∫ —Å–∏–ª—å–Ω–æ–º—É –∫–æ–º—å—é–Ω–∏—Ç–∏ —Ç—Ä–µ–π–¥–µ—Ä–æ–≤\n\n"
        "üî• –≠—Ç–æ –Ω–µ –ø—Ä–æ—Å—Ç–æ –ø–æ–¥–ø–∏—Å–∫–∞ –Ω–∞ GPT ‚Äî —ç—Ç–æ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç + –ø–æ–¥–¥–µ—Ä–∂–∫–∞ + –æ–ø—ã—Ç"
    )

    message = await context.bot.send_message(chat_id='@Cripto_inter_bot', text=text, reply_markup=keyboard)
    await context.bot.pin_chat_message(chat_id='@Cripto_inter_bot', message_id=message.message_id, disable_notification=True)

async def unified_text_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if context.user_data.get("awaiting_macro_for_image"):
        await handle_macro_for_image(update, context)
    else:
        await handle_main(update, context)

def main():
    app = ApplicationBuilder().token(TELEGRAM_TOKEN).build()

    conv_handler = ConversationHandler(
        entry_points=[
            MessageHandler(filters.Regex("^üìä –ü–æ–º–æ—â—å –ø—Ä–æ—Ñ–µ—Å—Å–∏–æ–Ω–∞–ª–∞$"), help_pro),
            MessageHandler(filters.Regex("^üßò –°–ø–æ–∫–æ–π—Å—Ç–≤–∏–µ$"), start_therapy)
        ],
        states={
            INTERPRET_NEWS: [MessageHandler(filters.TEXT & ~filters.COMMAND, interpret_decision)],
            ASK_EVENT: [MessageHandler(filters.TEXT & ~filters.COMMAND, ask_forecast)],
            ASK_FORECAST: [MessageHandler(filters.TEXT & ~filters.COMMAND, ask_actual)],
            ASK_ACTUAL: [MessageHandler(filters.TEXT & ~filters.COMMAND, generate_interpretation)],
            FOLLOWUP_1: [MessageHandler(filters.TEXT & ~filters.COMMAND, followup_strategy)],
            FOLLOWUP_2: [MessageHandler(filters.TEXT & ~filters.COMMAND, followup_timeframe)],
            FOLLOWUP_3: [MessageHandler(filters.TEXT & ~filters.COMMAND, followup_market)],
            GENERAL_QUESTION: [MessageHandler(filters.TEXT & ~filters.COMMAND, general_response)],
            WAITING_FOR_THERAPY_INPUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, gpt_psychologist_response)]
        },
        fallbacks=[CommandHandler("start", start)]
    )

    app.add_handler(CommandHandler("start", start))
    app.add_handler(CommandHandler("publish", publish_post))
    app.add_handler(conv_handler)

    # üìå –£–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω—ã–π —Ö–µ–Ω–¥–ª–µ—Ä –¥–ª—è –≤—Å–µ–≥–æ —Ç–µ–∫—Å—Ç–æ–≤–æ–≥–æ –≤–≤–æ–¥–∞
    app.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, unified_text_handler))

    # üìç –û–±—Ä–∞–±–æ—Ç–∫–∞ –∫–Ω–æ–ø–æ–∫ –∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π
    app.add_handler(CallbackQueryHandler(button_handler))
    app.add_handler(MessageHandler(filters.PHOTO, handle_photo))

    app.post_init = post_init
    app.run_polling()

if __name__ == '__main__':
    main()











